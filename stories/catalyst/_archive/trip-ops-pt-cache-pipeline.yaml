id: trip-ops-pt-cache-pipeline
title: "PT Cache — Redis Cache-Aside for High-Throughput GPS"
description: >
  The IPtCacheService pattern: how PassengerTrip aggregates are cached in Redis to
  reduce PostgreSQL load during 30-second GPS processing bursts. Cache-aside with
  three operations: GetOrLoadAsync (read-through), SetAsync (pre-warm), InvalidateAsync
  (evict on state transition). Target: 60% DB load reduction during active fleet hours.
renderer: service-flow
schemaVersion: "2.0"
layout: sequence

services:
  - id: gps-handler
    name: IngestGpsLocationCommand
    type: api
    technology: ".NET 10 — Command Handler"
    status: healthy

  - id: pt-cache
    name: PtCacheService
    type: cache
    technology: "Redis — IPtCacheService"
    status: healthy

  - id: redis
    name: Redis
    type: cache
    technology: "Redis 7 — TTL-based eviction"

  - id: trip-ops-db
    name: trip_operations DB
    type: database
    technology: "PostgreSQL 16"

  - id: state-handler
    name: State Transition Handler
    type: worker
    technology: "BoardPtCommand / DropOffPtCommand"
    status: healthy

  - id: eta-service
    name: ETA Calculation
    type: worker
    technology: "IEtaCalculationService"
    status: healthy

  - id: ep-handler
    name: EventProcessor
    type: event-processor
    technology: "PtStateChangedEventHandler"
    status: healthy

zones:
  - id: hot-path
    label: "Hot Path — 30-Second GPS Cycle"
    members: [gps-handler, pt-cache, eta-service]
    color: "rgba(239, 68, 68, 0.05)"
  - id: cache-layer
    label: "Cache Layer"
    members: [redis]
    color: "rgba(245, 158, 11, 0.06)"
  - id: cold-path
    label: "Cold Path — State Transitions"
    members: [state-handler, ep-handler]
    color: "rgba(59, 130, 246, 0.05)"

calls:
  # ── Hot Path: GPS ingestion needs PT data ──
  - id: gps-needs-pt
    type: sync
    from: gps-handler
    to: pt-cache
    method: INVOKE
    path: "GetOrLoadAsync(ptId, ct)"
    duration: 2
    status: ok
    note: "Every GPS fix needs PT data for ETA calculation. 33 vehicles × 8 PTs = 264 lookups per 30-second cycle."

  # Cache hit
  - id: cache-hit
    type: sync
    from: pt-cache
    to: redis
    method: GET
    path: "pt-cache:{tenantId}:{ptId}"
    duration: 1
    status: ok
    note: "Sub-millisecond Redis GET. Deserialized PassengerTrip returned. No DB round-trip."

  # Cache miss → DB fallback
  - id: cache-miss-db
    type: sync
    from: pt-cache
    to: trip-ops-db
    method: SELECT
    path: "PassengerTrips WHERE Id = @ptId (change-tracked)"
    duration: 12
    status: ok
    note: "Cache miss: 12ms PostgreSQL round-trip. PT loaded, then SET into Redis with TTL."

  # Populate cache after miss
  - id: populate-cache
    type: sync
    from: pt-cache
    to: redis
    method: SET
    path: "pt-cache:{tenantId}:{ptId} TTL=300s"
    duration: 1
    status: ok
    note: "5-minute TTL. Balances freshness vs. DB load. Active PTs stay warm during route execution."

  # ETA uses cached PT
  - id: eta-uses-pt
    type: sync
    from: gps-handler
    to: eta-service
    method: INVOKE
    path: "CalculateEta(pt, gpsReading)"
    duration: 12
    status: ok
    note: "ETA needs PT's ScheduledPickupTime, ScheduledDropoffTime, pickup/dropoff coords. All from cached PT."

  # ── Cold Path: State transition invalidates ──
  - id: state-transition
    type: sync
    from: state-handler
    to: pt-cache
    method: INVOKE
    path: "InvalidateAsync(ptId, ct)"
    duration: 1
    status: ok
    note: "BoardPtCommand, DropOffPtCommand, CancelTripCommand — any state change invalidates the cached PT."

  - id: invalidate-redis
    type: sync
    from: pt-cache
    to: redis
    method: DEL
    path: "pt-cache:{tenantId}:{ptId}"
    duration: 1
    status: ok
    note: "DEL key. Next GPS read for this PT will trigger cache miss → fresh DB load."

  # ── Pre-warm: SGR bulk load ──
  - id: pre-warm
    type: sync
    from: ep-handler
    to: pt-cache
    method: INVOKE
    path: "SetAsync(pt, ct) — bulk pre-warm after SGR"
    duration: 3
    status: ok
    note: "After SgrCompletedEvent, pre-warm cache for all newly-created PTs. Zero cold-start misses at route start."

  - id: pre-warm-redis
    type: sync
    from: pt-cache
    to: redis
    method: "MSET"
    path: "pt-cache:{tenantId}:{ptId} × N (batch pipeline)"
    duration: 25
    status: ok
    note: "Redis pipeline: MSET for all PTs in one round-trip. 500 PTs in ~25ms."

steps:
  - id: step-1
    title: "The Problem — 264 PT Lookups Every 30 Seconds"
    narrative: >
      During active fleet hours, 33 vehicles send GPS fixes every 30 seconds.
      Each GPS fix triggers ETA recalculation for all PassengerTrips on that VehicleRun —
      typically 8 PTs per VR. That's 33 × 8 = 264 PT lookups every 30 seconds.
      Without caching, that's 264 PostgreSQL round-trips (12ms each) = 3.2 seconds of DB time.
      With caching, it's 264 Redis GETs (1ms each) = 264ms. A 12× throughput improvement.
    activeCalls: []
    focusNodes: [gps-handler]
    duration: 6000
    narration:
      speaker: Architecture Lead
      message: "264 PT lookups per 30-second cycle. Without cache: 3.2s of DB time. With cache: 264ms. The cache-aside pattern makes GPS processing viable at scale."

  - id: step-2
    title: "Cache Hit — Sub-Millisecond Redis GET"
    narrative: >
      GetOrLoadAsync first checks Redis with key pt-cache:{tenantId}:{ptId}.
      On cache hit (expected 85%+ of the time during active routes), the serialized
      PassengerTrip is returned in sub-millisecond time. No PostgreSQL round-trip.
      The PT's ScheduledPickupTime, ScheduledDropoffTime, and coordinates are all
      the ETA calculator needs — and they're in cache from the pre-warm or a previous miss.
    activeCalls:
      - gps-needs-pt
      - cache-hit
    focusNodes: [gps-handler, pt-cache, redis]
    duration: 5500
    narration:
      speaker: Domain Expert
      message: "85%+ cache hit rate during active routes. Each hit saves 11ms of PostgreSQL latency. Over 264 lookups, that's 2.9 seconds saved per GPS cycle."

  - id: step-3
    title: "Cache Miss — DB Fallback + Auto-Populate"
    narrative: >
      On cache miss, GetOrLoadAsync falls back to PostgreSQL — loading the full
      PassengerTrip aggregate (12ms). After loading, SetAsync populates Redis with
      a 5-minute TTL. The next GPS cycle hitting this PT will get a cache hit.
      Cache misses are expected at route start (before pre-warm completes) and
      after state transitions that invalidated the cache.
    activeCalls:
      - cache-miss-db
      - populate-cache
    focusNodes: [pt-cache, trip-ops-db, redis]
    duration: 5500
    narration:
      speaker: Architect
      message: "5-minute TTL is the balance point. Long enough to survive 10 GPS cycles (5 minutes ÷ 30 seconds). Short enough to pick up state changes within 5 minutes."

  - id: step-4
    title: "ETA Calculation Uses Cached PT"
    narrative: >
      Once the PT is retrieved (from cache or DB), the GPS handler passes it to
      IEtaCalculationService along with the fresh GpsReading. ETA needs the PT's
      ScheduledPickupTime, ScheduledDropoffTime, PickupLatitude/Longitude, and
      DropoffLatitude/Longitude — all immutable during the active route.
      The result is an EstimatedTimeOfArrival VO with Likely, Optimistic, and Pessimistic times.
    activeCalls:
      - gps-needs-pt
      - eta-uses-pt
    focusNodes: [gps-handler, eta-service]
    duration: 5000
    narration:
      speaker: Domain Expert
      message: "The PT's scheduled times and coordinates are immutable during the route — perfect cache candidates. Only state (PtStatus) changes on transitions."

  - id: step-5
    title: "State Transition → Invalidate Cache"
    narrative: >
      When a PT transitions state (Board, DropOff, Cancel, NoShow), the command handler
      calls InvalidateAsync(ptId) which DELs the Redis key. This ensures the next
      GPS read gets a fresh PT from PostgreSQL with the updated status.
      Without invalidation, the cache would serve stale status for up to 5 minutes.
    activeCalls:
      - state-transition
      - invalidate-redis
    focusNodes: [state-handler, pt-cache, redis]
    duration: 5000
    narration:
      speaker: Architecture Lead
      message: "Invalidate-on-write is the cache-aside contract. State transition → DEL → next read sees fresh data. No stale reads for status-dependent logic."

  - id: step-6
    title: "Pre-Warm — Zero Cold-Start at Route Launch"
    narrative: >
      After SgrCompletedEvent, the EventProcessor bulk-loads all newly-created PTs
      and pre-warms the cache via SetAsync. Redis pipeline batches 500 PTs in ~25ms
      using MSET. When drivers start their routes the next morning, every PT lookup
      is a cache hit from the first GPS fix. Zero cold-start penalty.
    activeCalls:
      - pre-warm
      - pre-warm-redis
    focusNodes: [ep-handler, pt-cache, redis]
    duration: 5500
    narration:
      speaker: Architect
      message: "Pre-warm after SGR = zero cold starts. The morning rush hits 100% cache from the first GPS fix. Redis pipeline makes 500 SETs as fast as 1."

  - id: step-7
    title: "The Complete Cache-Aside Pipeline"
    narrative: >
      Three operations, one contract: GetOrLoadAsync (read-through with DB fallback),
      SetAsync (pre-warm after SGR), InvalidateAsync (evict on state change).
      Target: 60% DB load reduction during active fleet hours. Actual: 85%+ cache hit rate
      means ~85% fewer PT-related DB queries. The 5-minute TTL, state-transition invalidation,
      and SGR pre-warm create a self-sustaining cache that stays warm during the entire
      morning route window (6 AM – 9 AM) without manual intervention.
    activeCalls:
      - gps-needs-pt
      - cache-hit
      - cache-miss-db
      - populate-cache
      - eta-uses-pt
      - state-transition
      - invalidate-redis
      - pre-warm
      - pre-warm-redis
    duration: 7000
    narration:
      speaker: Architecture Lead
      message: "Cache-aside with three operations. 85%+ hit rate. 60% DB load reduction target exceeded. The GPS hot path stays under 35ms total."

camera:
  center: [0, 0]
  zoom: 1
